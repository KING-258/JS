{"ast":null,"code":"/**\n * This class represents a file that might not have all its data loaded yet.\n * It is used when loading the entire file is not an option because it's too\n * expensive. Instead, parts of the file are loaded and added only when needed.\n * From a reading point of view is as if the entire file is loaded. The\n * exception is when the data is not available yet, an error will be thrown.\n * This class does not load the data, it just manages it. It provides operations\n * to add and read data from the file.\n *\n * \n */\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar NOT_FOUND = -1;\nvar ChunkedFileData = /*#__PURE__*/function () {\n  function ChunkedFileData() {\n    _classCallCheck(this, ChunkedFileData);\n    _defineProperty(this, \"_fileData\", void 0);\n    this._fileData = [];\n  }\n  /**\n   * Adds data to the file storage at a specific offset.\n   */\n\n  _createClass(ChunkedFileData, [{\n    key: \"addData\",\n    value: function addData(offset, data) {\n      var offsetEnd = offset + data.length - 1;\n      var chunkRange = this._getChunkRange(offset, offsetEnd);\n      if (chunkRange.startIx === NOT_FOUND) {\n        this._fileData.splice(chunkRange.insertIx || 0, 0, {\n          offset: offset,\n          data: data\n        });\n      } else {\n        // If the data to add collides with existing chunks we prepend and\n        // append data from the half colliding chunks to make the collision at\n        // 100%. The new data can then replace all the colliding chunkes.\n        var firstChunk = this._fileData[chunkRange.startIx];\n        var lastChunk = this._fileData[chunkRange.endIx];\n        var needsPrepend = offset > firstChunk.offset;\n        var needsAppend = offsetEnd < lastChunk.offset + lastChunk.data.length - 1;\n        var chunk = {\n          offset: Math.min(offset, firstChunk.offset),\n          data: data\n        };\n        if (needsPrepend) {\n          var slicedData = this._sliceData(firstChunk.data, 0, offset - firstChunk.offset);\n          chunk.data = this._concatData(slicedData, data);\n        }\n        if (needsAppend) {\n          // Use the lastChunk because the slice logic is easier to handle.\n          var slicedData = this._sliceData(chunk.data, 0, lastChunk.offset - chunk.offset);\n          chunk.data = this._concatData(slicedData, lastChunk.data);\n        }\n        this._fileData.splice(chunkRange.startIx, chunkRange.endIx - chunkRange.startIx + 1, chunk);\n      }\n    }\n  }, {\n    key: \"_concatData\",\n    value: function _concatData(dataA, dataB) {\n      // TypedArrays don't support concat.\n      if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView && ArrayBuffer.isView(dataA)) {\n        // $FlowIssue - flow thinks dataAandB is a string but it's not\n        var dataAandB = new dataA.constructor(dataA.length + dataB.length); // $FlowIssue - flow thinks dataAandB is a string but it's not\n\n        dataAandB.set(dataA, 0); // $FlowIssue - flow thinks dataAandB is a string but it's not\n\n        dataAandB.set(dataB, dataA.length);\n        return dataAandB;\n      } else {\n        // $FlowIssue - flow thinks dataAandB is a TypedArray but it's not\n        return dataA.concat(dataB);\n      }\n    }\n  }, {\n    key: \"_sliceData\",\n    value: function _sliceData(data, begin, end) {\n      // Some TypeArray implementations do not support slice yet.\n      if (data.slice) {\n        return data.slice(begin, end);\n      } else {\n        // $FlowIssue - flow thinks data is a string but it's not\n        return data.subarray(begin, end);\n      }\n    }\n    /**\n     * Finds the chunk range that overlaps the [offsetStart-1,offsetEnd+1] range.\n     * When a chunk is adjacent to the offset we still consider it part of the\n     * range (this is the situation of offsetStart-1 or offsetEnd+1).\n     * When no chunks are found `insertIx` denotes the index where the data\n     * should be inserted in the data list (startIx == NOT_FOUND and endIX ==\n     * NOT_FOUND).\n     */\n  }, {\n    key: \"_getChunkRange\",\n    value: function _getChunkRange(offsetStart, offsetEnd) {\n      var startChunkIx = NOT_FOUND;\n      var endChunkIx = NOT_FOUND;\n      var insertIx = 0; // Could use binary search but not expecting that many blocks to exist.\n\n      for (var i = 0; i < this._fileData.length; i++, insertIx = i) {\n        var chunkOffsetStart = this._fileData[i].offset;\n        var chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.length;\n        if (offsetEnd < chunkOffsetStart - 1) {\n          // This offset range doesn't overlap with any chunks.\n          break;\n        } // If it is adjacent we still consider it part of the range because\n        // we're going end up with a single block with all contiguous data.\n\n        if (offsetStart <= chunkOffsetEnd + 1 && offsetEnd >= chunkOffsetStart - 1) {\n          startChunkIx = i;\n          break;\n        }\n      } // No starting chunk was found, meaning that the offset is either before\n      // or after the current stored chunks.\n\n      if (startChunkIx === NOT_FOUND) {\n        return {\n          startIx: NOT_FOUND,\n          endIx: NOT_FOUND,\n          insertIx: insertIx\n        };\n      } // Find the ending chunk.\n\n      for (var i = startChunkIx; i < this._fileData.length; i++) {\n        var chunkOffsetStart = this._fileData[i].offset;\n        var chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.length;\n        if (offsetEnd >= chunkOffsetStart - 1) {\n          // Candidate for the end chunk, it doesn't mean it is yet.\n          endChunkIx = i;\n        }\n        if (offsetEnd <= chunkOffsetEnd + 1) {\n          break;\n        }\n      }\n      if (endChunkIx === NOT_FOUND) {\n        endChunkIx = startChunkIx;\n      }\n      return {\n        startIx: startChunkIx,\n        endIx: endChunkIx\n      };\n    }\n  }, {\n    key: \"hasDataRange\",\n    value: function hasDataRange(offsetStart, offsetEnd) {\n      for (var i = 0; i < this._fileData.length; i++) {\n        var chunk = this._fileData[i];\n        if (offsetEnd < chunk.offset) {\n          return false;\n        }\n        if (offsetStart >= chunk.offset && offsetEnd < chunk.offset + chunk.data.length) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"getByteAt\",\n    value: function getByteAt(offset) {\n      var dataChunk;\n      for (var i = 0; i < this._fileData.length; i++) {\n        var dataChunkStart = this._fileData[i].offset;\n        var dataChunkEnd = dataChunkStart + this._fileData[i].data.length - 1;\n        if (offset >= dataChunkStart && offset <= dataChunkEnd) {\n          dataChunk = this._fileData[i];\n          break;\n        }\n      }\n      if (dataChunk) {\n        return dataChunk.data[offset - dataChunk.offset];\n      }\n      throw new Error(\"Offset \" + offset + \" hasn't been loaded yet.\");\n    }\n  }], [{\n    key: \"NOT_FOUND\",\n    get:\n    // $FlowIssue - get/set properties not yet supported\n    function get() {\n      return NOT_FOUND;\n    }\n  }]);\n  return ChunkedFileData;\n}();\nmodule.exports = ChunkedFileData;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","NOT_FOUND","ChunkedFileData","_fileData","addData","offset","data","offsetEnd","chunkRange","_getChunkRange","startIx","splice","insertIx","firstChunk","lastChunk","endIx","needsPrepend","needsAppend","chunk","Math","min","slicedData","_sliceData","_concatData","dataA","dataB","ArrayBuffer","isView","dataAandB","constructor","set","concat","begin","end","slice","subarray","offsetStart","startChunkIx","endChunkIx","chunkOffsetStart","chunkOffsetEnd","hasDataRange","getByteAt","dataChunk","dataChunkStart","dataChunkEnd","Error","get","module","exports"],"sources":["/home/el_professor258/Documents/music/node_modules/jsmediatags/build2/ChunkedFileData.js"],"sourcesContent":["/**\n * This class represents a file that might not have all its data loaded yet.\n * It is used when loading the entire file is not an option because it's too\n * expensive. Instead, parts of the file are loaded and added only when needed.\n * From a reading point of view is as if the entire file is loaded. The\n * exception is when the data is not available yet, an error will be thrown.\n * This class does not load the data, it just manages it. It provides operations\n * to add and read data from the file.\n *\n * \n */\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar NOT_FOUND = -1;\n\nvar ChunkedFileData = /*#__PURE__*/function () {\n  function ChunkedFileData() {\n    _classCallCheck(this, ChunkedFileData);\n\n    _defineProperty(this, \"_fileData\", void 0);\n\n    this._fileData = [];\n  }\n  /**\n   * Adds data to the file storage at a specific offset.\n   */\n\n\n  _createClass(ChunkedFileData, [{\n    key: \"addData\",\n    value: function addData(offset, data) {\n      var offsetEnd = offset + data.length - 1;\n\n      var chunkRange = this._getChunkRange(offset, offsetEnd);\n\n      if (chunkRange.startIx === NOT_FOUND) {\n        this._fileData.splice(chunkRange.insertIx || 0, 0, {\n          offset: offset,\n          data: data\n        });\n      } else {\n        // If the data to add collides with existing chunks we prepend and\n        // append data from the half colliding chunks to make the collision at\n        // 100%. The new data can then replace all the colliding chunkes.\n        var firstChunk = this._fileData[chunkRange.startIx];\n        var lastChunk = this._fileData[chunkRange.endIx];\n        var needsPrepend = offset > firstChunk.offset;\n        var needsAppend = offsetEnd < lastChunk.offset + lastChunk.data.length - 1;\n        var chunk = {\n          offset: Math.min(offset, firstChunk.offset),\n          data: data\n        };\n\n        if (needsPrepend) {\n          var slicedData = this._sliceData(firstChunk.data, 0, offset - firstChunk.offset);\n\n          chunk.data = this._concatData(slicedData, data);\n        }\n\n        if (needsAppend) {\n          // Use the lastChunk because the slice logic is easier to handle.\n          var slicedData = this._sliceData(chunk.data, 0, lastChunk.offset - chunk.offset);\n\n          chunk.data = this._concatData(slicedData, lastChunk.data);\n        }\n\n        this._fileData.splice(chunkRange.startIx, chunkRange.endIx - chunkRange.startIx + 1, chunk);\n      }\n    }\n  }, {\n    key: \"_concatData\",\n    value: function _concatData(dataA, dataB) {\n      // TypedArrays don't support concat.\n      if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView && ArrayBuffer.isView(dataA)) {\n        // $FlowIssue - flow thinks dataAandB is a string but it's not\n        var dataAandB = new dataA.constructor(dataA.length + dataB.length); // $FlowIssue - flow thinks dataAandB is a string but it's not\n\n        dataAandB.set(dataA, 0); // $FlowIssue - flow thinks dataAandB is a string but it's not\n\n        dataAandB.set(dataB, dataA.length);\n        return dataAandB;\n      } else {\n        // $FlowIssue - flow thinks dataAandB is a TypedArray but it's not\n        return dataA.concat(dataB);\n      }\n    }\n  }, {\n    key: \"_sliceData\",\n    value: function _sliceData(data, begin, end) {\n      // Some TypeArray implementations do not support slice yet.\n      if (data.slice) {\n        return data.slice(begin, end);\n      } else {\n        // $FlowIssue - flow thinks data is a string but it's not\n        return data.subarray(begin, end);\n      }\n    }\n    /**\n     * Finds the chunk range that overlaps the [offsetStart-1,offsetEnd+1] range.\n     * When a chunk is adjacent to the offset we still consider it part of the\n     * range (this is the situation of offsetStart-1 or offsetEnd+1).\n     * When no chunks are found `insertIx` denotes the index where the data\n     * should be inserted in the data list (startIx == NOT_FOUND and endIX ==\n     * NOT_FOUND).\n     */\n\n  }, {\n    key: \"_getChunkRange\",\n    value: function _getChunkRange(offsetStart, offsetEnd) {\n      var startChunkIx = NOT_FOUND;\n      var endChunkIx = NOT_FOUND;\n      var insertIx = 0; // Could use binary search but not expecting that many blocks to exist.\n\n      for (var i = 0; i < this._fileData.length; i++, insertIx = i) {\n        var chunkOffsetStart = this._fileData[i].offset;\n        var chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.length;\n\n        if (offsetEnd < chunkOffsetStart - 1) {\n          // This offset range doesn't overlap with any chunks.\n          break;\n        } // If it is adjacent we still consider it part of the range because\n        // we're going end up with a single block with all contiguous data.\n\n\n        if (offsetStart <= chunkOffsetEnd + 1 && offsetEnd >= chunkOffsetStart - 1) {\n          startChunkIx = i;\n          break;\n        }\n      } // No starting chunk was found, meaning that the offset is either before\n      // or after the current stored chunks.\n\n\n      if (startChunkIx === NOT_FOUND) {\n        return {\n          startIx: NOT_FOUND,\n          endIx: NOT_FOUND,\n          insertIx: insertIx\n        };\n      } // Find the ending chunk.\n\n\n      for (var i = startChunkIx; i < this._fileData.length; i++) {\n        var chunkOffsetStart = this._fileData[i].offset;\n        var chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.length;\n\n        if (offsetEnd >= chunkOffsetStart - 1) {\n          // Candidate for the end chunk, it doesn't mean it is yet.\n          endChunkIx = i;\n        }\n\n        if (offsetEnd <= chunkOffsetEnd + 1) {\n          break;\n        }\n      }\n\n      if (endChunkIx === NOT_FOUND) {\n        endChunkIx = startChunkIx;\n      }\n\n      return {\n        startIx: startChunkIx,\n        endIx: endChunkIx\n      };\n    }\n  }, {\n    key: \"hasDataRange\",\n    value: function hasDataRange(offsetStart, offsetEnd) {\n      for (var i = 0; i < this._fileData.length; i++) {\n        var chunk = this._fileData[i];\n\n        if (offsetEnd < chunk.offset) {\n          return false;\n        }\n\n        if (offsetStart >= chunk.offset && offsetEnd < chunk.offset + chunk.data.length) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getByteAt\",\n    value: function getByteAt(offset) {\n      var dataChunk;\n\n      for (var i = 0; i < this._fileData.length; i++) {\n        var dataChunkStart = this._fileData[i].offset;\n        var dataChunkEnd = dataChunkStart + this._fileData[i].data.length - 1;\n\n        if (offset >= dataChunkStart && offset <= dataChunkEnd) {\n          dataChunk = this._fileData[i];\n          break;\n        }\n      }\n\n      if (dataChunk) {\n        return dataChunk.data[offset - dataChunk.offset];\n      }\n\n      throw new Error(\"Offset \" + offset + \" hasn't been loaded yet.\");\n    }\n  }], [{\n    key: \"NOT_FOUND\",\n    get: // $FlowIssue - get/set properties not yet supported\n    function get() {\n      return NOT_FOUND;\n    }\n  }]);\n\n  return ChunkedFileData;\n}();\n\nmodule.exports = ChunkedFileData;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}