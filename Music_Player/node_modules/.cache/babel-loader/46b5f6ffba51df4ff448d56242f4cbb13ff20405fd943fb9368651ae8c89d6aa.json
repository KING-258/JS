{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar MediaFileReader = require(\"./MediaFileReader\");\nvar XhrFileReader = require(\"./XhrFileReader\");\nvar BlobFileReader = require(\"./BlobFileReader\");\nvar ArrayFileReader = require(\"./ArrayFileReader\");\nvar MediaTagReader = require(\"./MediaTagReader\");\nvar ID3v1TagReader = require(\"./ID3v1TagReader\");\nvar ID3v2TagReader = require(\"./ID3v2TagReader\");\nvar MP4TagReader = require(\"./MP4TagReader\");\nvar FLACTagReader = require(\"./FLACTagReader\");\nvar mediaFileReaders = [];\nvar mediaTagReaders = [];\nfunction read(location, callbacks) {\n  new Reader(location).read(callbacks);\n}\nfunction isRangeValid(range, fileSize) {\n  var invalidPositiveRange = range.offset >= 0 && range.offset + range.length >= fileSize;\n  var invalidNegativeRange = range.offset < 0 && (-range.offset > fileSize || range.offset + range.length > 0);\n  return !(invalidPositiveRange || invalidNegativeRange);\n}\nvar Reader = /*#__PURE__*/function () {\n  function Reader(file) {\n    _classCallCheck(this, Reader);\n    _defineProperty(this, \"_file\", void 0);\n    _defineProperty(this, \"_tagsToRead\", void 0);\n    _defineProperty(this, \"_fileReader\", void 0);\n    _defineProperty(this, \"_tagReader\", void 0);\n    this._file = file;\n  }\n  _createClass(Reader, [{\n    key: \"setTagsToRead\",\n    value: function setTagsToRead(tagsToRead) {\n      this._tagsToRead = tagsToRead;\n      return this;\n    }\n  }, {\n    key: \"setFileReader\",\n    value: function setFileReader(fileReader) {\n      this._fileReader = fileReader;\n      return this;\n    }\n  }, {\n    key: \"setTagReader\",\n    value: function setTagReader(tagReader) {\n      this._tagReader = tagReader;\n      return this;\n    }\n  }, {\n    key: \"read\",\n    value: function read(callbacks) {\n      var FileReader = this._getFileReader();\n      var fileReader = new FileReader(this._file);\n      var self = this;\n      fileReader.init({\n        onSuccess: function onSuccess() {\n          self._getTagReader(fileReader, {\n            onSuccess: function onSuccess(TagReader) {\n              new TagReader(fileReader).setTagsToRead(self._tagsToRead).read(callbacks);\n            },\n            onError: callbacks.onError\n          });\n        },\n        onError: callbacks.onError\n      });\n    }\n  }, {\n    key: \"_getFileReader\",\n    value: function _getFileReader() {\n      if (this._fileReader) {\n        return this._fileReader;\n      } else {\n        return this._findFileReader();\n      }\n    }\n  }, {\n    key: \"_findFileReader\",\n    value: function _findFileReader() {\n      for (var i = 0; i < mediaFileReaders.length; i++) {\n        if (mediaFileReaders[i].canReadFile(this._file)) {\n          return mediaFileReaders[i];\n        }\n      }\n      throw new Error(\"No suitable file reader found for \" + this._file);\n    }\n  }, {\n    key: \"_getTagReader\",\n    value: function _getTagReader(fileReader, callbacks) {\n      if (this._tagReader) {\n        var tagReader = this._tagReader;\n        setTimeout(function () {\n          callbacks.onSuccess(tagReader);\n        }, 1);\n      } else {\n        this._findTagReader(fileReader, callbacks);\n      }\n    }\n  }, {\n    key: \"_findTagReader\",\n    value: function _findTagReader(fileReader, callbacks) {\n      // We don't want to make multiple fetches per tag reader to get the tag\n      // identifier. The strategy here is to combine all the tag identifier\n      // ranges into one and make a single fetch. This is particularly important\n      // in file readers that have expensive loads like the XHR one.\n      // However, with this strategy we run into the problem of loading the\n      // entire file because tag identifiers might be at the start or end of\n      // the file.\n      // To get around this we divide the tag readers into two categories, the\n      // ones that read their tag identifiers from the start of the file and the\n      // ones that read from the end of the file.\n      var tagReadersAtFileStart = [];\n      var tagReadersAtFileEnd = [];\n      var fileSize = fileReader.getSize();\n      for (var i = 0; i < mediaTagReaders.length; i++) {\n        var range = mediaTagReaders[i].getTagIdentifierByteRange();\n        if (!isRangeValid(range, fileSize)) {\n          continue;\n        }\n        if (range.offset >= 0 && range.offset < fileSize / 2 || range.offset < 0 && range.offset < -fileSize / 2) {\n          tagReadersAtFileStart.push(mediaTagReaders[i]);\n        } else {\n          tagReadersAtFileEnd.push(mediaTagReaders[i]);\n        }\n      }\n      var tagsLoaded = false;\n      var loadTagIdentifiersCallbacks = {\n        onSuccess: function onSuccess() {\n          if (!tagsLoaded) {\n            // We're expecting to load two sets of tag identifiers. This flag\n            // indicates when the first one has been loaded.\n            tagsLoaded = true;\n            return;\n          }\n          for (var i = 0; i < mediaTagReaders.length; i++) {\n            var range = mediaTagReaders[i].getTagIdentifierByteRange();\n            if (!isRangeValid(range, fileSize)) {\n              continue;\n            }\n            try {\n              var tagIndentifier = fileReader.getBytesAt(range.offset >= 0 ? range.offset : range.offset + fileSize, range.length);\n            } catch (ex) {\n              if (callbacks.onError) {\n                callbacks.onError({\n                  \"type\": \"fileReader\",\n                  \"info\": ex.message\n                });\n              }\n              return;\n            }\n            if (mediaTagReaders[i].canReadTagFormat(tagIndentifier)) {\n              callbacks.onSuccess(mediaTagReaders[i]);\n              return;\n            }\n          }\n          if (callbacks.onError) {\n            callbacks.onError({\n              \"type\": \"tagFormat\",\n              \"info\": \"No suitable tag reader found\"\n            });\n          }\n        },\n        onError: callbacks.onError\n      };\n      this._loadTagIdentifierRanges(fileReader, tagReadersAtFileStart, loadTagIdentifiersCallbacks);\n      this._loadTagIdentifierRanges(fileReader, tagReadersAtFileEnd, loadTagIdentifiersCallbacks);\n    }\n  }, {\n    key: \"_loadTagIdentifierRanges\",\n    value: function _loadTagIdentifierRanges(fileReader, tagReaders, callbacks) {\n      if (tagReaders.length === 0) {\n        // Force async\n        setTimeout(callbacks.onSuccess, 1);\n        return;\n      }\n      var tagIdentifierRange = [Number.MAX_VALUE, 0];\n      var fileSize = fileReader.getSize(); // Create a super set of all ranges so we can load them all at once.\n      // Might need to rethink this approach if there are tag ranges too far\n      // a part from each other. We're good for now though.\n\n      for (var i = 0; i < tagReaders.length; i++) {\n        var range = tagReaders[i].getTagIdentifierByteRange();\n        var start = range.offset >= 0 ? range.offset : range.offset + fileSize;\n        var end = start + range.length - 1;\n        tagIdentifierRange[0] = Math.min(start, tagIdentifierRange[0]);\n        tagIdentifierRange[1] = Math.max(end, tagIdentifierRange[1]);\n      }\n      fileReader.loadRange(tagIdentifierRange, callbacks);\n    }\n  }]);\n  return Reader;\n}();\nvar Config = /*#__PURE__*/function () {\n  function Config() {\n    _classCallCheck(this, Config);\n  }\n  _createClass(Config, null, [{\n    key: \"addFileReader\",\n    value: function addFileReader(fileReader) {\n      mediaFileReaders.push(fileReader);\n      return Config;\n    }\n  }, {\n    key: \"addTagReader\",\n    value: function addTagReader(tagReader) {\n      mediaTagReaders.push(tagReader);\n      return Config;\n    }\n  }, {\n    key: \"removeTagReader\",\n    value: function removeTagReader(tagReader) {\n      var tagReaderIx = mediaTagReaders.indexOf(tagReader);\n      if (tagReaderIx >= 0) {\n        mediaTagReaders.splice(tagReaderIx, 1);\n      }\n      return Config;\n    }\n  }, {\n    key: \"EXPERIMENTAL_avoidHeadRequests\",\n    value: function EXPERIMENTAL_avoidHeadRequests() {\n      XhrFileReader.setConfig({\n        avoidHeadRequests: true\n      });\n    }\n  }, {\n    key: \"setDisallowedXhrHeaders\",\n    value: function setDisallowedXhrHeaders(disallowedXhrHeaders) {\n      XhrFileReader.setConfig({\n        disallowedXhrHeaders: disallowedXhrHeaders\n      });\n    }\n  }, {\n    key: \"setXhrTimeoutInSec\",\n    value: function setXhrTimeoutInSec(timeoutInSec) {\n      XhrFileReader.setConfig({\n        timeoutInSec: timeoutInSec\n      });\n    }\n  }]);\n  return Config;\n}();\nConfig.addFileReader(XhrFileReader).addFileReader(BlobFileReader).addFileReader(ArrayFileReader).addTagReader(ID3v2TagReader).addTagReader(ID3v1TagReader).addTagReader(MP4TagReader).addTagReader(FLACTagReader);\nif (typeof process !== \"undefined\" && !process.browser) {\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    var ReactNativeFileReader = require('./ReactNativeFileReader');\n    Config.addFileReader(ReactNativeFileReader);\n  } else {\n    var NodeFileReader = require('./NodeFileReader');\n    Config.addFileReader(NodeFileReader);\n  }\n}\nmodule.exports = {\n  \"read\": read,\n  \"Reader\": Reader,\n  \"Config\": Config\n};","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","MediaFileReader","require","XhrFileReader","BlobFileReader","ArrayFileReader","MediaTagReader","ID3v1TagReader","ID3v2TagReader","MP4TagReader","FLACTagReader","mediaFileReaders","mediaTagReaders","read","location","callbacks","Reader","isRangeValid","range","fileSize","invalidPositiveRange","offset","invalidNegativeRange","file","_file","setTagsToRead","tagsToRead","_tagsToRead","setFileReader","fileReader","_fileReader","setTagReader","tagReader","_tagReader","FileReader","_getFileReader","self","init","onSuccess","_getTagReader","TagReader","onError","_findFileReader","canReadFile","Error","setTimeout","_findTagReader","tagReadersAtFileStart","tagReadersAtFileEnd","getSize","getTagIdentifierByteRange","push","tagsLoaded","loadTagIdentifiersCallbacks","tagIndentifier","getBytesAt","ex","message","canReadTagFormat","_loadTagIdentifierRanges","tagReaders","tagIdentifierRange","Number","MAX_VALUE","start","end","Math","min","max","loadRange","Config","addFileReader","addTagReader","removeTagReader","tagReaderIx","indexOf","splice","EXPERIMENTAL_avoidHeadRequests","setConfig","avoidHeadRequests","setDisallowedXhrHeaders","disallowedXhrHeaders","setXhrTimeoutInSec","timeoutInSec","process","browser","navigator","product","ReactNativeFileReader","NodeFileReader","module","exports"],"sources":["/home/el_professor258/Documents/music/node_modules/jsmediatags/build2/jsmediatags.js"],"sourcesContent":["'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar MediaFileReader = require(\"./MediaFileReader\");\n\nvar XhrFileReader = require(\"./XhrFileReader\");\n\nvar BlobFileReader = require(\"./BlobFileReader\");\n\nvar ArrayFileReader = require(\"./ArrayFileReader\");\n\nvar MediaTagReader = require(\"./MediaTagReader\");\n\nvar ID3v1TagReader = require(\"./ID3v1TagReader\");\n\nvar ID3v2TagReader = require(\"./ID3v2TagReader\");\n\nvar MP4TagReader = require(\"./MP4TagReader\");\n\nvar FLACTagReader = require(\"./FLACTagReader\");\n\nvar mediaFileReaders = [];\nvar mediaTagReaders = [];\n\nfunction read(location, callbacks) {\n  new Reader(location).read(callbacks);\n}\n\nfunction isRangeValid(range, fileSize) {\n  var invalidPositiveRange = range.offset >= 0 && range.offset + range.length >= fileSize;\n  var invalidNegativeRange = range.offset < 0 && (-range.offset > fileSize || range.offset + range.length > 0);\n  return !(invalidPositiveRange || invalidNegativeRange);\n}\n\nvar Reader = /*#__PURE__*/function () {\n  function Reader(file) {\n    _classCallCheck(this, Reader);\n\n    _defineProperty(this, \"_file\", void 0);\n\n    _defineProperty(this, \"_tagsToRead\", void 0);\n\n    _defineProperty(this, \"_fileReader\", void 0);\n\n    _defineProperty(this, \"_tagReader\", void 0);\n\n    this._file = file;\n  }\n\n  _createClass(Reader, [{\n    key: \"setTagsToRead\",\n    value: function setTagsToRead(tagsToRead) {\n      this._tagsToRead = tagsToRead;\n      return this;\n    }\n  }, {\n    key: \"setFileReader\",\n    value: function setFileReader(fileReader) {\n      this._fileReader = fileReader;\n      return this;\n    }\n  }, {\n    key: \"setTagReader\",\n    value: function setTagReader(tagReader) {\n      this._tagReader = tagReader;\n      return this;\n    }\n  }, {\n    key: \"read\",\n    value: function read(callbacks) {\n      var FileReader = this._getFileReader();\n\n      var fileReader = new FileReader(this._file);\n      var self = this;\n      fileReader.init({\n        onSuccess: function onSuccess() {\n          self._getTagReader(fileReader, {\n            onSuccess: function onSuccess(TagReader) {\n              new TagReader(fileReader).setTagsToRead(self._tagsToRead).read(callbacks);\n            },\n            onError: callbacks.onError\n          });\n        },\n        onError: callbacks.onError\n      });\n    }\n  }, {\n    key: \"_getFileReader\",\n    value: function _getFileReader() {\n      if (this._fileReader) {\n        return this._fileReader;\n      } else {\n        return this._findFileReader();\n      }\n    }\n  }, {\n    key: \"_findFileReader\",\n    value: function _findFileReader() {\n      for (var i = 0; i < mediaFileReaders.length; i++) {\n        if (mediaFileReaders[i].canReadFile(this._file)) {\n          return mediaFileReaders[i];\n        }\n      }\n\n      throw new Error(\"No suitable file reader found for \" + this._file);\n    }\n  }, {\n    key: \"_getTagReader\",\n    value: function _getTagReader(fileReader, callbacks) {\n      if (this._tagReader) {\n        var tagReader = this._tagReader;\n        setTimeout(function () {\n          callbacks.onSuccess(tagReader);\n        }, 1);\n      } else {\n        this._findTagReader(fileReader, callbacks);\n      }\n    }\n  }, {\n    key: \"_findTagReader\",\n    value: function _findTagReader(fileReader, callbacks) {\n      // We don't want to make multiple fetches per tag reader to get the tag\n      // identifier. The strategy here is to combine all the tag identifier\n      // ranges into one and make a single fetch. This is particularly important\n      // in file readers that have expensive loads like the XHR one.\n      // However, with this strategy we run into the problem of loading the\n      // entire file because tag identifiers might be at the start or end of\n      // the file.\n      // To get around this we divide the tag readers into two categories, the\n      // ones that read their tag identifiers from the start of the file and the\n      // ones that read from the end of the file.\n      var tagReadersAtFileStart = [];\n      var tagReadersAtFileEnd = [];\n      var fileSize = fileReader.getSize();\n\n      for (var i = 0; i < mediaTagReaders.length; i++) {\n        var range = mediaTagReaders[i].getTagIdentifierByteRange();\n\n        if (!isRangeValid(range, fileSize)) {\n          continue;\n        }\n\n        if (range.offset >= 0 && range.offset < fileSize / 2 || range.offset < 0 && range.offset < -fileSize / 2) {\n          tagReadersAtFileStart.push(mediaTagReaders[i]);\n        } else {\n          tagReadersAtFileEnd.push(mediaTagReaders[i]);\n        }\n      }\n\n      var tagsLoaded = false;\n      var loadTagIdentifiersCallbacks = {\n        onSuccess: function onSuccess() {\n          if (!tagsLoaded) {\n            // We're expecting to load two sets of tag identifiers. This flag\n            // indicates when the first one has been loaded.\n            tagsLoaded = true;\n            return;\n          }\n\n          for (var i = 0; i < mediaTagReaders.length; i++) {\n            var range = mediaTagReaders[i].getTagIdentifierByteRange();\n\n            if (!isRangeValid(range, fileSize)) {\n              continue;\n            }\n\n            try {\n              var tagIndentifier = fileReader.getBytesAt(range.offset >= 0 ? range.offset : range.offset + fileSize, range.length);\n            } catch (ex) {\n              if (callbacks.onError) {\n                callbacks.onError({\n                  \"type\": \"fileReader\",\n                  \"info\": ex.message\n                });\n              }\n\n              return;\n            }\n\n            if (mediaTagReaders[i].canReadTagFormat(tagIndentifier)) {\n              callbacks.onSuccess(mediaTagReaders[i]);\n              return;\n            }\n          }\n\n          if (callbacks.onError) {\n            callbacks.onError({\n              \"type\": \"tagFormat\",\n              \"info\": \"No suitable tag reader found\"\n            });\n          }\n        },\n        onError: callbacks.onError\n      };\n\n      this._loadTagIdentifierRanges(fileReader, tagReadersAtFileStart, loadTagIdentifiersCallbacks);\n\n      this._loadTagIdentifierRanges(fileReader, tagReadersAtFileEnd, loadTagIdentifiersCallbacks);\n    }\n  }, {\n    key: \"_loadTagIdentifierRanges\",\n    value: function _loadTagIdentifierRanges(fileReader, tagReaders, callbacks) {\n      if (tagReaders.length === 0) {\n        // Force async\n        setTimeout(callbacks.onSuccess, 1);\n        return;\n      }\n\n      var tagIdentifierRange = [Number.MAX_VALUE, 0];\n      var fileSize = fileReader.getSize(); // Create a super set of all ranges so we can load them all at once.\n      // Might need to rethink this approach if there are tag ranges too far\n      // a part from each other. We're good for now though.\n\n      for (var i = 0; i < tagReaders.length; i++) {\n        var range = tagReaders[i].getTagIdentifierByteRange();\n        var start = range.offset >= 0 ? range.offset : range.offset + fileSize;\n        var end = start + range.length - 1;\n        tagIdentifierRange[0] = Math.min(start, tagIdentifierRange[0]);\n        tagIdentifierRange[1] = Math.max(end, tagIdentifierRange[1]);\n      }\n\n      fileReader.loadRange(tagIdentifierRange, callbacks);\n    }\n  }]);\n\n  return Reader;\n}();\n\nvar Config = /*#__PURE__*/function () {\n  function Config() {\n    _classCallCheck(this, Config);\n  }\n\n  _createClass(Config, null, [{\n    key: \"addFileReader\",\n    value: function addFileReader(fileReader) {\n      mediaFileReaders.push(fileReader);\n      return Config;\n    }\n  }, {\n    key: \"addTagReader\",\n    value: function addTagReader(tagReader) {\n      mediaTagReaders.push(tagReader);\n      return Config;\n    }\n  }, {\n    key: \"removeTagReader\",\n    value: function removeTagReader(tagReader) {\n      var tagReaderIx = mediaTagReaders.indexOf(tagReader);\n\n      if (tagReaderIx >= 0) {\n        mediaTagReaders.splice(tagReaderIx, 1);\n      }\n\n      return Config;\n    }\n  }, {\n    key: \"EXPERIMENTAL_avoidHeadRequests\",\n    value: function EXPERIMENTAL_avoidHeadRequests() {\n      XhrFileReader.setConfig({\n        avoidHeadRequests: true\n      });\n    }\n  }, {\n    key: \"setDisallowedXhrHeaders\",\n    value: function setDisallowedXhrHeaders(disallowedXhrHeaders) {\n      XhrFileReader.setConfig({\n        disallowedXhrHeaders: disallowedXhrHeaders\n      });\n    }\n  }, {\n    key: \"setXhrTimeoutInSec\",\n    value: function setXhrTimeoutInSec(timeoutInSec) {\n      XhrFileReader.setConfig({\n        timeoutInSec: timeoutInSec\n      });\n    }\n  }]);\n\n  return Config;\n}();\n\nConfig.addFileReader(XhrFileReader).addFileReader(BlobFileReader).addFileReader(ArrayFileReader).addTagReader(ID3v2TagReader).addTagReader(ID3v1TagReader).addTagReader(MP4TagReader).addTagReader(FLACTagReader);\n\nif (typeof process !== \"undefined\" && !process.browser) {\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    var ReactNativeFileReader = require('./ReactNativeFileReader');\n\n    Config.addFileReader(ReactNativeFileReader);\n  } else {\n    var NodeFileReader = require('./NodeFileReader');\n\n    Config.addFileReader(NodeFileReader);\n  }\n}\n\nmodule.exports = {\n  \"read\": read,\n  \"Reader\": Reader,\n  \"Config\": Config\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}