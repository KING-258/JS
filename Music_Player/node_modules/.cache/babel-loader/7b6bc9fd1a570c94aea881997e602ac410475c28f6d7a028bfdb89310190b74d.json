{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar MediaFileReader = require('./MediaFileReader');\nvar MediaTagReader = /*#__PURE__*/function () {\n  function MediaTagReader(mediaFileReader) {\n    _classCallCheck(this, MediaTagReader);\n    _defineProperty(this, \"_mediaFileReader\", void 0);\n    _defineProperty(this, \"_tags\", void 0);\n    this._mediaFileReader = mediaFileReader;\n    this._tags = null;\n  }\n  /**\n   * Returns the byte range that needs to be loaded and fed to\n   * _canReadTagFormat in order to identify if the file contains tag\n   * information that can be read.\n   */\n\n  _createClass(MediaTagReader, [{\n    key: \"setTagsToRead\",\n    value: function setTagsToRead(tags) {\n      this._tags = tags;\n      return this;\n    }\n  }, {\n    key: \"read\",\n    value: function read(callbacks) {\n      var self = this;\n      this._mediaFileReader.init({\n        onSuccess: function onSuccess() {\n          self._loadData(self._mediaFileReader, {\n            onSuccess: function onSuccess() {\n              try {\n                var tags = self._parseData(self._mediaFileReader, self._tags);\n              } catch (ex) {\n                if (callbacks.onError) {\n                  callbacks.onError({\n                    \"type\": \"parseData\",\n                    \"info\": ex.message\n                  });\n                  return;\n                }\n              } // TODO: destroy mediaFileReader\n\n              callbacks.onSuccess(tags);\n            },\n            onError: callbacks.onError\n          });\n        },\n        onError: callbacks.onError\n      });\n    }\n  }, {\n    key: \"getShortcuts\",\n    value: function getShortcuts() {\n      return {};\n    }\n    /**\n     * Load the necessary bytes from the media file.\n     */\n  }, {\n    key: \"_loadData\",\n    value: function _loadData(mediaFileReader, callbacks) {\n      throw new Error(\"Must implement _loadData function\");\n    }\n    /**\n     * Parse the loaded data to read the media tags.\n     */\n  }, {\n    key: \"_parseData\",\n    value: function _parseData(mediaFileReader, tags) {\n      throw new Error(\"Must implement _parseData function\");\n    }\n  }, {\n    key: \"_expandShortcutTags\",\n    value: function _expandShortcutTags(tagsWithShortcuts) {\n      if (!tagsWithShortcuts) {\n        return null;\n      }\n      var tags = [];\n      var shortcuts = this.getShortcuts();\n      for (var i = 0, tagOrShortcut; tagOrShortcut = tagsWithShortcuts[i]; i++) {\n        tags = tags.concat(shortcuts[tagOrShortcut] || [tagOrShortcut]);\n      }\n      return tags;\n    }\n  }], [{\n    key: \"getTagIdentifierByteRange\",\n    value: function getTagIdentifierByteRange() {\n      throw new Error(\"Must implement\");\n    }\n    /**\n     * Given a tag identifier (read from the file byte positions speficied by\n     * getTagIdentifierByteRange) this function checks if it can read the tag\n     * format or not.\n     */\n  }, {\n    key: \"canReadTagFormat\",\n    value: function canReadTagFormat(tagIdentifier) {\n      throw new Error(\"Must implement\");\n    }\n  }]);\n  return MediaTagReader;\n}();\nmodule.exports = MediaTagReader;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","MediaFileReader","require","MediaTagReader","mediaFileReader","_mediaFileReader","_tags","setTagsToRead","tags","read","callbacks","self","init","onSuccess","_loadData","_parseData","ex","onError","message","getShortcuts","Error","_expandShortcutTags","tagsWithShortcuts","shortcuts","tagOrShortcut","concat","getTagIdentifierByteRange","canReadTagFormat","tagIdentifier","module","exports"],"sources":["/home/el_professor258/Documents/music/node_modules/jsmediatags/build2/MediaTagReader.js"],"sourcesContent":["'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar MediaFileReader = require('./MediaFileReader');\n\nvar MediaTagReader = /*#__PURE__*/function () {\n  function MediaTagReader(mediaFileReader) {\n    _classCallCheck(this, MediaTagReader);\n\n    _defineProperty(this, \"_mediaFileReader\", void 0);\n\n    _defineProperty(this, \"_tags\", void 0);\n\n    this._mediaFileReader = mediaFileReader;\n    this._tags = null;\n  }\n  /**\n   * Returns the byte range that needs to be loaded and fed to\n   * _canReadTagFormat in order to identify if the file contains tag\n   * information that can be read.\n   */\n\n\n  _createClass(MediaTagReader, [{\n    key: \"setTagsToRead\",\n    value: function setTagsToRead(tags) {\n      this._tags = tags;\n      return this;\n    }\n  }, {\n    key: \"read\",\n    value: function read(callbacks) {\n      var self = this;\n\n      this._mediaFileReader.init({\n        onSuccess: function onSuccess() {\n          self._loadData(self._mediaFileReader, {\n            onSuccess: function onSuccess() {\n              try {\n                var tags = self._parseData(self._mediaFileReader, self._tags);\n              } catch (ex) {\n                if (callbacks.onError) {\n                  callbacks.onError({\n                    \"type\": \"parseData\",\n                    \"info\": ex.message\n                  });\n                  return;\n                }\n              } // TODO: destroy mediaFileReader\n\n\n              callbacks.onSuccess(tags);\n            },\n            onError: callbacks.onError\n          });\n        },\n        onError: callbacks.onError\n      });\n    }\n  }, {\n    key: \"getShortcuts\",\n    value: function getShortcuts() {\n      return {};\n    }\n    /**\n     * Load the necessary bytes from the media file.\n     */\n\n  }, {\n    key: \"_loadData\",\n    value: function _loadData(mediaFileReader, callbacks) {\n      throw new Error(\"Must implement _loadData function\");\n    }\n    /**\n     * Parse the loaded data to read the media tags.\n     */\n\n  }, {\n    key: \"_parseData\",\n    value: function _parseData(mediaFileReader, tags) {\n      throw new Error(\"Must implement _parseData function\");\n    }\n  }, {\n    key: \"_expandShortcutTags\",\n    value: function _expandShortcutTags(tagsWithShortcuts) {\n      if (!tagsWithShortcuts) {\n        return null;\n      }\n\n      var tags = [];\n      var shortcuts = this.getShortcuts();\n\n      for (var i = 0, tagOrShortcut; tagOrShortcut = tagsWithShortcuts[i]; i++) {\n        tags = tags.concat(shortcuts[tagOrShortcut] || [tagOrShortcut]);\n      }\n\n      return tags;\n    }\n  }], [{\n    key: \"getTagIdentifierByteRange\",\n    value: function getTagIdentifierByteRange() {\n      throw new Error(\"Must implement\");\n    }\n    /**\n     * Given a tag identifier (read from the file byte positions speficied by\n     * getTagIdentifierByteRange) this function checks if it can read the tag\n     * format or not.\n     */\n\n  }, {\n    key: \"canReadTagFormat\",\n    value: function canReadTagFormat(tagIdentifier) {\n      throw new Error(\"Must implement\");\n    }\n  }]);\n\n  return MediaTagReader;\n}();\n\nmodule.exports = MediaTagReader;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}