{"ast":null,"code":"var _jsxFileName = \"/home/el_professor258/Documents/snake/src/App.js\",\n  _s = $RefreshSig$();\n// App.js\n\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GRID_SIZE = 20;\nconst App = () => {\n  _s();\n  const [grid, setGrid] = useState([]);\n  const [snake, setSnake] = useState([{\n    x: 10,\n    y: 10\n  }]);\n  const [food, setFood] = useState({\n    x: 15,\n    y: 15\n  });\n  const [direction, setDirection] = useState('RIGHT');\n  const [automation, setAutomation] = useState(false);\n  useEffect(() => {\n    const updateGrid = () => {\n      const newGrid = [];\n      for (let i = 0; i < GRID_SIZE; i++) {\n        const row = [];\n        for (let j = 0; j < GRID_SIZE; j++) {\n          row.push(0);\n        }\n        newGrid.push(row);\n      }\n      snake.forEach(segment => {\n        newGrid[segment.y][segment.x] = 1;\n      });\n      newGrid[food.y][food.x] = 2;\n      setGrid(newGrid);\n    };\n    updateGrid();\n  }, [snake, food]);\n  useEffect(() => {\n    if (automation) {\n      const interval = setInterval(() => {\n        moveSnake();\n      }, 500);\n      return () => clearInterval(interval);\n    }\n  }, [automation, snake]);\n  useEffect(() => {\n    const handleKeyPress = event => {\n      switch (event.key) {\n        case 'ArrowUp':\n          if (direction !== 'DOWN') setDirection('UP');\n          break;\n        case 'ArrowDown':\n          if (direction !== 'UP') setDirection('DOWN');\n          break;\n        case 'ArrowLeft':\n          if (direction !== 'RIGHT') setDirection('LEFT');\n          break;\n        case 'ArrowRight':\n          if (direction !== 'LEFT') setDirection('RIGHT');\n          break;\n        default:\n          break;\n      }\n    };\n    document.addEventListener('keydown', handleKeyPress);\n    return () => {\n      document.removeEventListener('keydown', handleKeyPress);\n    };\n  }, [direction]);\n  const moveSnake = () => {\n    const newSnake = [...snake];\n    const head = {\n      ...newSnake[0]\n    };\n    switch (direction) {\n      case 'UP':\n        head.y = (head.y - 1 + GRID_SIZE) % GRID_SIZE;\n        break;\n      case 'DOWN':\n        head.y = (head.y + 1) % GRID_SIZE;\n        break;\n      case 'LEFT':\n        head.x = (head.x - 1 + GRID_SIZE) % GRID_SIZE;\n        break;\n      case 'RIGHT':\n        head.x = (head.x + 1) % GRID_SIZE;\n        break;\n      default:\n        break;\n    }\n\n    // Check for collision with itself\n    const collided = newSnake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);\n    if (collided) {\n      // Game over logic\n      setAutomation(false);\n      return;\n    }\n    newSnake.unshift(head);\n    if (head.x === food.x && head.y === food.y) {\n      generateFood();\n    } else {\n      newSnake.pop();\n    }\n    setSnake(newSnake);\n  };\n  const checkCollision = () => {\n    const head = snake[0];\n    // Check if snake collides with itself\n    const collided = snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);\n    if (collided) {\n      setAutomation(false); // Game over\n    }\n  };\n  const generateFood = () => {\n    const newFood = {\n      x: Math.floor(Math.random() * GRID_SIZE),\n      y: Math.floor(Math.random() * GRID_SIZE)\n    };\n    setFood(newFood);\n  };\n  const toggleAutomation = () => {\n    setAutomation(!automation);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"row\",\n      children: row.map((cell, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `cell ${cell === 1 ? 'snake' : cell === 2 ? 'food' : ''}`\n      }, colIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 135,\n        columnNumber: 13\n      }, this))\n    }, rowIndex, false, {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 9\n    }, this)), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: toggleAutomation,\n      children: automation ? 'Disable Automation' : 'Enable Automation'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 131,\n    columnNumber: 5\n  }, this);\n};\n_s(App, \"zgsB+zo6niSbDB6hGFrP4IL+g/Y=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","GRID_SIZE","App","_s","grid","setGrid","snake","setSnake","x","y","food","setFood","direction","setDirection","automation","setAutomation","updateGrid","newGrid","i","row","j","push","forEach","segment","interval","setInterval","moveSnake","clearInterval","handleKeyPress","event","key","document","addEventListener","removeEventListener","newSnake","head","collided","slice","some","unshift","generateFood","pop","checkCollision","newFood","Math","floor","random","toggleAutomation","className","children","map","rowIndex","cell","colIndex","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["/home/el_professor258/Documents/snake/src/App.js"],"sourcesContent":["// App.js\n\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\n\nconst GRID_SIZE = 20;\n\nconst App = () => {\n  const [grid, setGrid] = useState([]);\n  const [snake, setSnake] = useState([{ x: 10, y: 10 }]);\n  const [food, setFood] = useState({ x: 15, y: 15 });\n  const [direction, setDirection] = useState('RIGHT');\n  const [automation, setAutomation] = useState(false);\n\n  useEffect(() => {\n    const updateGrid = () => {\n      const newGrid = [];\n      for (let i = 0; i < GRID_SIZE; i++) {\n        const row = [];\n        for (let j = 0; j < GRID_SIZE; j++) {\n          row.push(0);\n        }\n        newGrid.push(row);\n      }\n      snake.forEach(segment => {\n        newGrid[segment.y][segment.x] = 1;\n      });\n      newGrid[food.y][food.x] = 2;\n      setGrid(newGrid);\n    };\n    updateGrid();\n  }, [snake, food]);\n\n  useEffect(() => {\n    if (automation) {\n      const interval = setInterval(() => {\n        moveSnake();\n      }, 500);\n      return () => clearInterval(interval);\n    }\n  }, [automation, snake]);\n\n  useEffect(() => {\n    const handleKeyPress = (event) => {\n      switch (event.key) {\n        case 'ArrowUp':\n          if (direction !== 'DOWN') setDirection('UP');\n          break;\n        case 'ArrowDown':\n          if (direction !== 'UP') setDirection('DOWN');\n          break;\n        case 'ArrowLeft':\n          if (direction !== 'RIGHT') setDirection('LEFT');\n          break;\n        case 'ArrowRight':\n          if (direction !== 'LEFT') setDirection('RIGHT');\n          break;\n        default:\n          break;\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyPress);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyPress);\n    };\n  }, [direction]);\n\n  const moveSnake = () => {\n    const newSnake = [...snake];\n    const head = { ...newSnake[0] };\n\n    switch (direction) {\n      case 'UP':\n        head.y = (head.y - 1 + GRID_SIZE) % GRID_SIZE;\n        break;\n      case 'DOWN':\n        head.y = (head.y + 1) % GRID_SIZE;\n        break;\n      case 'LEFT':\n        head.x = (head.x - 1 + GRID_SIZE) % GRID_SIZE;\n        break;\n      case 'RIGHT':\n        head.x = (head.x + 1) % GRID_SIZE;\n        break;\n      default:\n        break;\n    }\n\n    // Check for collision with itself\n    const collided = newSnake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);\n    if (collided) {\n      // Game over logic\n      setAutomation(false);\n      return;\n    }\n\n    newSnake.unshift(head);\n    if (head.x === food.x && head.y === food.y) {\n      generateFood();\n    } else {\n      newSnake.pop();\n    }\n\n    setSnake(newSnake);\n  };\n\n  const checkCollision = () => {\n    const head = snake[0];\n    // Check if snake collides with itself\n    const collided = snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);\n    if (collided) {\n      setAutomation(false); // Game over\n    }\n  };\n\n  const generateFood = () => {\n    const newFood = {\n      x: Math.floor(Math.random() * GRID_SIZE),\n      y: Math.floor(Math.random() * GRID_SIZE)\n    };\n    setFood(newFood);\n  };\n\n  const toggleAutomation = () => {\n    setAutomation(!automation);\n  };\n\n  return (\n    <div className=\"App\">\n      {grid.map((row, rowIndex) => (\n        <div key={rowIndex} className=\"row\">\n          {row.map((cell, colIndex) => (\n            <div key={colIndex} className={`cell ${cell === 1 ? 'snake' : cell === 2 ? 'food' : ''}`}></div>\n          ))}\n        </div>\n      ))}\n      <button onClick={toggleAutomation}>{automation ? 'Disable Automation' : 'Enable Automation'}</button>\n    </div>\n  );\n};\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}